---
title: 浏览器工作原理及浏览器结构
date: 2021-12-03
sidebar: 'auto'
tags:
 - 浏览器
---

# 浏览器工作原理

输入网址--**DNS域名解析**，找到IP地址，找到服务器--通过**TCP握手机制**与服务器建立连接（https会多一步TLS握手建立加密隧道）--发送**http请求**得到**响应**--受到tcp连接的限制浏览器会先收到**14kb**的数据，后续会慢慢增加传输速度（所以对于服务器来说在这个14kb内完整地展现网页数据就很重要）--浏览器开始渲染网页

关键渲染路径

* 解析html并构建DOM树
  * 在解析过程中是顺序解析并且只有一个主线程，如果遇到script标签就会加载js代码并且解析，这个时候就会暂停解析html当js代码全部解析完成后才会继续
  * 对于css链接、img标签、设置async和defer的script标签不会影响解析过程，而是会异步加载
* 构建CSSOM（css object module）树  
* 合并DOM和CSSOM，生成渲染树layout tree
* 布局
  * 生成渲染树之后，浏览器会根据**可见节点**，根据它们的宽高对它们进行规划
  * 对于像img这样的标签，if 没有指定宽高，浏览器 会忽略它的大小，等加载完成之后，浏览器会根据它的宽高位置再次计算受影响的节点和位置，这个过程叫做**回流**
* 绘制
  * 在第一次布局完成之后，会把**节点和节点样式绘制**到屏幕上
  * 如果发生了回流，浏览器会把变化的布局**重新绘制**到屏幕上，这个过程叫做**重绘** 

在上述五步完成之后，设置了defer以及async的js文件加载并执行

# 浏览器结构

### 用户界面

* 用于展示除标签页窗口以外的其他页面内容

### 浏览器引擎

* 用于再用户界面和渲染引擎之间传递数据 

#### 数据持久层

* 用来帮助浏览器存储各种数据  cookie

### 渲染引擎(浏览器内核)

* 用于渲染用户请求的页面内容

#### 网络模块

#### JS解析器

# 多进程浏览器结构

根据进程功能不同可以分为：

![image-20211203111046807](/image-20211203111046807.png)

## 浏览器进程

* 负责控制除标签页外的用户界面，包括地址栏、数千、后退和前进按钮
* 负责与浏览器其他进程协调工作

## 网络进程

* 负责发起接受网络请求

## GPU进程

* 负责整个浏览器界面的渲染

## 插件进程

* 负责控制网站使用的所有插件，eg：flash（不是扩展程序）

## 渲染器进程

* 负责控制及显示tab标签
* 浏览器默认可能（跟选择的进程模式有关）会给每一个标签页创建一个进程，每个进程相互隔离互不影响

## 缓存进程

# 流程

* 输入网址
* 浏览器进程的UI线程捕捉输入内容
  * if访问的是网址
    * UI线程启动一个网络线程，请求DNS进行域名解析
    * 开始连接服务器获取数据 ————跳转到第三点
  * else 关键词
    * 使用默认配置的搜索引擎来查询
* 获取到数据
* 通过safeBrowsing来检查站点是否是恶意站点
  * if 是
    * 展示警告页面，阻止你访问/自己手动继续访问
  * else
    * 网络线程把获取到的数据给UI线程
    * UI线程会创建一个渲染器进程来渲染页面
    * 浏览器进程通过IPC管道将数据传输给渲染器进程————开始渲染————跳转下一点
* 解析HTML构建DOM树————转以上浏览器工作原理
* 当生成完layout tree之后，主线程将这些信息传递给合成器线程
* 合成器线程将每个图层栅格化
  * 因为每个图层都可能会很大
  * 合成器线程就会将其切分为许多图块
  * 然后将每个土块发送给栅格化线程
  * 栅格化线程栅格化每个图块，并将其存储在GPU内存当中
* 当栅格化完成之后，合成器线程将其收集起来成为“draw quads”的图块信息，这些信息里记录了图块在内存当中的位置，和在页面的哪个位置绘制图片的信息
* 根据这些信息，合成器线程生成一个合成器帧
* 然后这个合成器帧通过IPC传送给浏览器进程
* 接着浏览器进程将合成器帧传送到GPU 
* 最后GPU渲染展示到屏幕上

![image-20211203114553087](/image-20211203114553087.png)

![image-20211203114939744](/image-20211203114939744.png)
