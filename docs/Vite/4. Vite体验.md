# vite启动项目初体验

开箱即用（out of box）：你不需要做任何额外的配置就可以使用vite来帮你处理构建工作

在默认情况下，我们的esmodule去导入资源的时候，要么是绝对路径，要么是相对路径，不会去处理你下载的资源包

# vite的依赖预构建

vite在处理过程中如果看到了有非绝对路径或者相对路径的引用（`import _ from "lodash"`）,vite就会尝试开启路径补全

```javascript
import _ from "/node_module/.vite/lodash";
```

找寻依赖的过程是自当前目录依次向上查找的过程，直到搜索到根目录或者搜寻到对应依赖为止

## 依赖预构建

> 首先vite会找到对应的依赖，然后调用esbuild（对js语法进行处理的一个库），将其他规范的代码转换成esmodule规范，然后放到当前目录下的node_modules/.vite/deps，同时对esmodule规范的各个模块进行统一集成

**依赖预构建解决的问题**

1. 不同的第三方包会有不同的导出格式（这个是vite没法约束人家的事情）

2. 对路径的处理上可以直接使用。vite/deps，方便路径重写

3. 网络多包传输的性能问题（也是原生esmodule规范不敢支持node_modules的原因之一），有了依赖预构建以后无论他有多少的额外export和import，vite都会尽可能地将他们进行集成最后只生成一个或几个模块

   ```js
   // vite.config.js
   optimizeDeps: {
       exclude: ["依赖名"] // 当遇到当前依赖地时候不进行依赖预构建
   }
   ```

# vite配置文件的语法提示以及开发环境和生产环境区分

## 不同编辑器中使用语法提示

1. `vscode`中使用`defineConfig`

```js
// vite.config.js
import { defineConfig } from "vite"
export default defineConfig({
    // 配置项
})
```

2. 使用@type进行类型约束

```js
// vite.config.js
/** @type import("vite").UserConfig */
const viteConfig = {
    // 配置项
}

export default viteConfig;
```

## 环境配置

```js
 // vite.config.js
import viteBaseConfig from './vite.base.config';
import viteDevConfig from './vite.dev.config';
import viteProdConfig from './vite.prod.config';

// 策略模式
const envResolver = {
    'build': () => {
        console.log('生产环境');
        return ({...viteBaseConfig, ...viteProdConfig})
    },
    'serve': () => {
        console.log('开发环境');
        return Object.assign({}, viteBaseConfig, viteDevConfig)
    }
}

/** @type import("vite").UserConfig */
export default ({command}) => {
    return envResolver[command]();
}
```

# vite 环境变量配置

> **环境变量**：会根据当前的代码环境产生值得比那花得变量就叫做环境变量

代码环境：

* 开发环境  `.env.development`
* 测试环境 `.env.test`
* 预发布环境
* 灰度环境
* 生产环境 `.env.production`

## 在vite中的环境变量处理：

> 使用dotenv第三方库（vite内置）

dotenv会自动读取.env文件，并解析这个文件中的对应环境变量，并将其注入到process对象下（但是vite考虑到和其他配置的一些冲突问题，它不会直接注入到process对象下）

涉及到vite.config.js中的一些配置(会影响env文件中环境变量配置)

- root
- envDir：用来配置当前环境变量的文件地址

vite提供了loadEnv方法来手动确认env文件

当我们调用loadEnv的时候，它会做以下几件事：

* 直接找到.env文件并解析其中的环境变量，并放进一个对象里
* 会将传进来的mode这个变量的值进行拼接 `.env.production` 并根据我们提供的目录去取对应的配置文件并进行解析，并放进一个对象里面 

```js
// vite.config.js
// process.cwd() ->  返回当前node进程的工作目录
// process.env
export default ({command, mode}) => {
    // 第二个参数是当前env文件所在的目录，大多数情况下.env文件在根目录下，所以可以使用process.cwd()来表示
    const env = loadEnv(mode, process.cwd(), '')
}
```

* .env：所有环境都需要用到的环境变量
* .env.development: 开发环境需要用到的环境（默认情况下vite将我们的开发环境取名为development）
* .env.production: 生产环境需要用到的环境（默认情况下vite将我们的生产环境取名为production）

**环境取名**

在`package.json`文件中的`scripts`属性，--mode来进行设置 配置，然后在vite.config.js中的mode取到的值就是这里配置的

## 在客户端使用环境变量

> 因为vite.config.js是在node端进行运行的，所以以上都是基于node端环境变量的配置

那么在客户端应该怎么使用呢？

客户端会把环境变量放在`**import.meta.env**`里面

在这里vite做了一层拦截，它为了防止我们将隐私性的变量直接送进`import.meta.env`中

如果你的环境变量不是以VITE开头的，它就不会帮你注入到客户端中去。

当然这里的VITE不是绝对的，它可以在`vite.config.js`中使用`envPrefix`属性来进行配置

```js
// vite.config.js
export default {
	envPrefix: 'ENV' // 配置注入到客户端的环境变量的前缀  默认：VITE_
}
```



# 补充

**`vite.config.js`在node端进行运行，那为什么它可以书写成esmodule的形式**

因为vite在读取vite.vonfig.js的时候会率先node去解析文件语法，如果发现你是esmodule规范会直接将你的esmodule规范进行替换变成commonjs规范